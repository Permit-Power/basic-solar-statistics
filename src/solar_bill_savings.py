"""
Module: solar_bill_savings
==========================

This module computes weighted average Year-1 and lifetime bill savings
from rooftop solar using dGen per-state outputs, and provides utilities
to export those results to a repository-tracked CSV for use in automated
pipelines (e.g., GitHub Actions).

Typical directory structure for raw dGen outputs:

    /path/to/per_state_outputs/
        {state_abbr}/
            {run_name}/
                policy.csv

Each `policy.csv` must contain at least:

    - new_adopters
    - utility_bill_wo_sys_pv_only
    - utility_bill_w_sys_pv_only

where the bill columns are 25-element arrays serialized as strings, e.g.:

    "{0,354.6,374.65,...}"

The first element (index 0) is always 0. Year-1 bills are at index 1.

Core functions
--------------

1. compute_state_bill_savings(base_directory, run_name)
   Reads raw dGen outputs from the filesystem and returns a per-state
   DataFrame of weighted bill savings.

2. export_state_bill_savings_to_csv(base_directory, run_name, export_directory, output_filename)
   Computes state-level savings using the function above and writes the
   results to a CSV in a repository-tracked directory.

3. compute_state_bill_savings_from_export(export_directory, run_name, filename)
   Loads a pre-computed CSV (e.g., generated by the export helper) and
   returns the same schema, for use in environments where raw dGen
   outputs are not available (e.g., CI).
"""

import os
from pathlib import Path
from typing import List, Dict, Optional

import pandas as pd


def _parse_bill_array(arr_str: str) -> List[float]:
    """
    Parse a 25-element bill array of the form:
        "{0,354.6,374.65,...}"

    and return a list of floats.

    Parameters
    ----------
    arr_str : str
        String representation of a PySAM bill array.

    Returns
    -------
    list of float
        Parsed numeric values in order. Returns an empty list if the input
        is not a string, empty, or cannot be parsed.
    """
    if not isinstance(arr_str, str):
        return []

    cleaned = arr_str.strip().lstrip("{").rstrip("}")
    if not cleaned:
        return []

    try:
        return [float(x) for x in cleaned.split(",")]
    except ValueError:
        return []


def _compute_row_metrics(row: pd.Series) -> Dict[str, float]:
    """
    Compute Year-1 bills and lifetime savings for a single policy row.

    Parameters
    ----------
    row : pandas.Series
        Row containing:
            - new_adopters
            - utility_bill_wo_sys_pv_only
            - utility_bill_w_sys_pv_only

    Returns
    -------
    dict
        Dictionary with keys:
            - bill_wo_y1 : float
            - bill_w_y1  : float
            - life_savings : float
            - weight : float

        If the bill arrays are missing or malformed, all values are 0.0.
    """
    wo_arr = _parse_bill_array(row["utility_bill_wo_sys_pv_only"])
    w_arr = _parse_bill_array(row["utility_bill_w_sys_pv_only"])

    if len(wo_arr) < 2 or len(w_arr) < 2:
        return {
            "bill_wo_y1": 0.0,
            "bill_w_y1": 0.0,
            "life_savings": 0.0,
            "weight": 0.0,
        }

    # Year-1 = index 1 (exclude index 0 which is always zero)
    bill_wo_y1 = wo_arr[1]
    bill_w_y1 = w_arr[1]

    # Lifetime savings = sum of years 1â€“24 (indices 1..24)
    life_wo = sum(wo_arr[1:])
    life_w = sum(w_arr[1:])
    life_savings = life_wo - life_w

    weight = float(row.get("new_adopters", 0.0) or 0.0)

    return {
        "bill_wo_y1": bill_wo_y1,
        "bill_w_y1": bill_w_y1,
        "life_savings": life_savings,
        "weight": weight,
    }


def _process_policy_csv(csv_path: str) -> pd.DataFrame:
    """
    Load and process one policy.csv file into per-row bill metrics.

    Parameters
    ----------
    csv_path : str
        Path to a policy.csv file.

    Returns
    -------
    pandas.DataFrame
        Columns:
            - bill_wo_y1
            - bill_w_y1
            - life_savings
            - weight

        Returns an empty DataFrame with these columns if required inputs
        are missing.
    """
    df = pd.read_csv(csv_path)

    required = [
        "new_adopters",
        "utility_bill_wo_sys_pv_only",
        "utility_bill_w_sys_pv_only",
    ]

    for col in required:
        if col not in df.columns:
            return pd.DataFrame(
                columns=["bill_wo_y1", "bill_w_y1", "life_savings", "weight"]
            )

    return df.apply(_compute_row_metrics, axis=1, result_type="expand")


def compute_state_bill_savings(base_directory: str, run_name: str) -> pd.DataFrame:
    """
    Compute weighted average Year-1 bill savings and 25-year lifetime
    savings by state using dGen per-state outputs.

    This function reads directly from the per_state_outputs directory
    arranged by state and run name.

    Directory structure expected:

        {base_directory}/{state_abbr}/{run_name}/policy.csv

    Parameters
    ----------
    base_directory : str
        Path to the per_state_outputs directory, for example:
        "/Volumes/Seagate Portabl/permit_power/dgen_runs/per_state_outputs"

    run_name : str
        Name of the dGen run directory under each state, for example:
        "run_all_states_net_savings_adjust_loan_params".

    Returns
    -------
    pandas.DataFrame
        One row per state, with columns:
            - state_abbr
            - weighted_avg_bill_without_pv_year1
            - weighted_avg_bill_with_pv_year1
            - weighted_avg_savings_year1
            - pct_savings_year1
            - lifetime_savings_weighted
    """
    results = []

    # Iterate over state directories
    for state_abbr in sorted(os.listdir(base_directory)):
        state_path = os.path.join(base_directory, state_abbr)
        if not os.path.isdir(state_path):
            continue

        policy_path = os.path.join(state_path, run_name, "policy.csv")
        if not os.path.isfile(policy_path):
            continue  # skip missing states

        df_metrics = _process_policy_csv(policy_path)
        if df_metrics.empty:
            continue

        total_weight = df_metrics["weight"].sum()
        if total_weight == 0:
            continue

        # Weighted Year-1 bills
        bill_wo_y1 = (df_metrics["bill_wo_y1"] * df_metrics["weight"]).sum() / total_weight
        bill_w_y1 = (df_metrics["bill_w_y1"] * df_metrics["weight"]).sum() / total_weight

        # Percentage savings in Year 1
        if bill_wo_y1 > 0:
            pct_savings_y1 = (bill_wo_y1 - bill_w_y1) / bill_wo_y1
        else:
            pct_savings_y1 = 0.0

        # Weighted lifetime savings
        life_savings_w = (
            df_metrics["life_savings"] * df_metrics["weight"]
        ).sum() / total_weight

        results.append(
            {
                "state_abbr": state_abbr.upper(),
                "weighted_avg_bill_without_pv_year1": bill_wo_y1,
                "weighted_avg_bill_with_pv_year1": bill_w_y1,
                "weighted_avg_savings_year1": bill_wo_y1 - bill_w_y1,
                "pct_savings_year1": pct_savings_y1,
                "lifetime_savings_weighted": life_savings_w,
            }
        )

    return pd.DataFrame(results)


def export_state_bill_savings_to_csv(
    base_directory: str,
    run_name: str,
    export_directory: str,
    output_filename: Optional[str] = None,
) -> str:
    """
    Compute state-level bill savings from raw dGen outputs and export
    the aggregated results to a CSV inside a repository-tracked directory.

    This helper is intended for use on a machine that has access to the
    per_state_outputs tree. Automated pipelines (e.g., CI) can then read
    the exported CSV via compute_state_bill_savings_from_export, avoiding
    any dependency on external drives.

    Parameters
    ----------
    base_directory : str
        Path to the per_state_outputs directory on the local or external
        filesystem, for example:
        "/Volumes/Seagate Portabl/permit_power/dgen_runs/per_state_outputs"

    run_name : str
        Name of the dGen run directory under each state, for example:
        "run_all_states_net_savings_adjust_loan_params".

    export_directory : str
        Path (relative or absolute) to the directory where the aggregated
        CSV should be written. This should typically point inside the
        repository, for example:
        "../data/bill_savings_csvs".

    output_filename : str, optional
        Name of the output CSV file. If None, defaults to:
        f"{run_name}_state_bill_savings.csv".

    Returns
    -------
    str
        Absolute path to the written CSV file.
    """
    export_dir_path = Path(export_directory).resolve()
    export_dir_path.mkdir(parents=True, exist_ok=True)

    if output_filename is None:
        output_filename = f"{run_name}_state_bill_savings.csv"

    output_path = export_dir_path / output_filename

    df = compute_state_bill_savings(base_directory=base_directory, run_name=run_name)

    # Ensure deterministic column ordering for easier inspection and diffs.
    desired_order = [
        "state_abbr",
        "weighted_avg_bill_without_pv_year1",
        "weighted_avg_bill_with_pv_year1",
        "weighted_avg_savings_year1",
        "pct_savings_year1",
        "lifetime_savings_weighted",
    ]
    cols = [c for c in desired_order if c in df.columns] + [
        c for c in df.columns if c not in desired_order
    ]
    df = df[cols]

    df.to_csv(output_path, index=False)
    return str(output_path)


def compute_state_bill_savings_from_export(
    export_directory: str,
    run_name: str,
    filename: Optional[str] = None,
) -> pd.DataFrame:
    """
    Load pre-computed state-level bill savings from an exported CSV.

    This function is intended for use in environments where the raw dGen
    per-state outputs are not available (for example, GitHub Actions),
    but an aggregated CSV has been generated and stored in the repo.

    The CSV is expected to be produced by export_state_bill_savings_to_csv.

    Parameters
    ----------
    export_directory : str
        Path (relative or absolute) to the directory containing the
        state bill savings CSVs. Typically something like:
        "../data/bill_savings_csvs".

    run_name : str
        Name of the run used when exporting, for example:
        "run_all_states_net_savings_adjust_loan_params".

    filename : str, optional
        CSV filename. If None, defaults to:
        f"{run_name}_state_bill_savings.csv".

    Returns
    -------
    pandas.DataFrame
        Columns matching the output of compute_state_bill_savings, i.e.:
            - state_abbr
            - weighted_avg_bill_without_pv_year1
            - weighted_avg_bill_with_pv_year1
            - weighted_avg_savings_year1
            - pct_savings_year1
            - lifetime_savings_weighted

        Any additional columns present in the CSV are passed through unchanged.

    Raises
    ------
    FileNotFoundError
        If the expected CSV file does not exist.
    """
    if filename is None:
        filename = f"{run_name}_state_bill_savings.csv"

    csv_path = Path(export_directory).resolve() / filename

    if not csv_path.is_file():
        raise FileNotFoundError(
            f"Exported bill savings CSV not found at: {csv_path}. "
            "Run export_state_bill_savings_to_csv() on a machine with access "
            "to the dGen per_state_outputs directory and ensure the CSV is "
            "available in the repository."
        )

    return pd.read_csv(csv_path)
